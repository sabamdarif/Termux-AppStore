#!/data/data/com.termux/files/usr/bin/bash

termux_desktop_path="/data/data/com.termux/files/usr/etc/termux-desktop"
config_file="$termux_desktop_path/configuration.conf"

function print_success() {
	echo -e "\033[32m[✓]\033[0m $1"
}

function print_failed() {
	echo -e "\033[31m[✗]\033[0m $1"
	exit 1
}

function print_warn() {
	echo -e "\033[33m[!]\033[0m $1"
}

function print_status() {
	echo -e "\033[36m[*]\033[0m $1"
}

function print_cmd() {
	echo -e "\033[35m[$]\033[0m \033[1m$1\033[0m"
}

function print_header() {
	echo -e "\033[1;44;97m $1 \033[0m"
}

function print_section() {
	echo
	echo -e "\033[1;34m=== $1 ===\033[0m"
}

function wait_for_keypress() {
	read -n1 -s -r -p "Press any key to continue..."
	echo
}

function check_and_create_directory() {
	local max_retries=3
	local attempt=1

	while ((attempt <= max_retries)); do
		if [[ ! -d "$1" ]]; then
			mkdir -p "$1" && break
		fi
		((attempt++))
		sleep 1
	done
}

function check_and_delete() {
	local max_retries=3
	local attempt=1

	for item in "$@"; do
		while ((attempt <= max_retries)); do
			if [[ -e "$item" ]]; then
				rm -rf "$item" >/dev/null 2>&1 && break
			fi
			((attempt++))
			sleep 1
		done
	done
}

# first check then backup
function check_and_backup() {
	local max_retries=3
	local attempt=1

	for files_folders in "$@"; do
		for file in $files_folders; do
			if [[ -e "$file" ]]; then
				local date_str=$(date +"%d-%m-%Y")
				local backup="${file}-${date_str}.bak"

				while ((attempt <= max_retries)); do
					if mv "$file" "$backup"; then
						echo "backed up file $file"
						break
					fi
					((attempt++))
					sleep 1
				done
			fi
		done
	done
}

function download_file() {
	local dest
	local url
	local max_retries=5
	local attempt=1
	local successful_attempt=0
	if [[ -z "$2" ]]; then
		url="$1"
		dest="$(basename "$url")"
	else
		dest="$1"
		url="$2"
	fi
	if [[ -z "$url" ]]; then
		print_failed "No URL provided!"
	fi
	while [[ $attempt -le $max_retries ]]; do
		print_msg "Downloading $dest..."
		if [[ ! -s "$dest" ]]; then
			check_and_delete "$dest"
		fi
		if command -v aria2c &>/dev/null; then
			# Use aria2c with console log level info for basic progress info
			aria2c -x10 --retry-wait=5 --max-tries=5 --dir="./" --out="$dest" "$url"
		elif command -v wget &>/dev/null; then
			wget --tries=5 --timeout=15 --retry-connrefused -O "$dest" "$url"
		else
			curl -# -L "$url" -o "$dest"
		fi
		if [[ -f "$dest" && -s "$dest" ]]; then
			successful_attempt=$attempt
			break
		else
			print_failed "Download failed. Retrying... ($attempt/$max_retries)"
		fi
		((attempt++))
	done
	if [[ -f "$dest" ]]; then
		if [[ $successful_attempt -eq 1 ]]; then
			print_success "File downloaded successfully."
		else
			print_success "File downloaded successfully on attempt $successful_attempt."
		fi
		return 0
	fi
	print_failed "Failed to download the file after $max_retries attempts. Exiting."
}

function extract() {
	local archive="$1"
	local output_dir="$2"
	local max_retries=5
	local attempt=1

	echo "Preparing to extract $archive"

	while ((attempt <= max_retries)); do
		if [[ ! -f "$archive" ]]; then
			print_failed "Error: '$archive' does not exist!"
		fi

		local dir_arg=""
		if [[ -n "$output_dir" ]]; then
			echo "Creating output directory: $output_dir"
			check_and_create_directory "$output_dir"
			dir_arg="-C $output_dir"
		fi

		echo "Extracting $(basename "$archive") (Attempt $attempt/$max_retries)"

		case "$archive" in
		*.tar.gz | *.tgz)
			echo "Extracting tar.gz archive"
			if tar xvzf "$archive" $dir_arg --no-same-owner -h || {
				print_failed "Failed to extract ${C}$archive"
			}; then
				echo "Finalizing extraction"
				break
			fi
			;;
		*.tar.xz)
			echo "Extracting tar.xz archive"
			if tar xvJf "$archive" $dir_arg --no-same-owner -h || {
				print_failed "Failed to extract ${C}$archive"
			}; then
				echo "Finalizing extraction"
				break
			fi
			;;
		*.tar.bz2 | *.tbz2)
			echo "Extracting tar.bz2 archive"
			if tar xvjf "$archive" $dir_arg --no-same-owner -h || {
				print_failed "Failed to extract ${C}$archive"
			}; then
				echo "Finalizing extraction"
				break
			fi
			;;
		*.tar)
			echo "Extracting tar archive"
			if tar xvf "$archive" $dir_arg --no-same-owner -h || {
				print_failed "Failed to extract ${C}$archive"
			}; then
				echo "Finalizing extraction"
				break
			fi
			;;
		*.bz2)
			echo "Extracting bz2 file"
			if [[ -n "$output_dir" ]]; then
				echo "Decompressing to target directory"
				bunzip2 -c "$archive" >"$output_dir/$(basename "${archive%.bz2}")" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "Finalizing bz2 extraction"
				break
			else
				echo "Decompressing in current directory"
				bunzip2 "$archive" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "Finalizing bz2 extraction"
				break
			fi
			;;
		*.gz)
			echo "PROGRESS:30:Extracting gz file"
			if [[ -n "$output_dir" ]]; then
				echo "PROGRESS:60:Decompressing to target directory"
				gunzip -c "$archive" >"$output_dir/$(basename "${archive%.gz}")" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing gz extraction"
				break
			else
				echo "PROGRESS:60:Decompressing in current directory"
				gunzip -c "$archive" >"${archive%.gz}" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing gz extraction"
				break
			fi
			;;
		*.7z)
			echo "PROGRESS:30:Extracting 7z file"
			if [[ -n "$output_dir" ]]; then
				echo "PROGRESS:50:Decompressing to target directory"
				7z x "$archive" -o"$output_dir" -y || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing 7z extraction"
				break
			else
				echo "PROGRESS:50:Decompressing in current directory"
				7z x "$archive" -y || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing 7z extraction"
				break
			fi
			;;
		*.rar)
			echo "PROGRESS:30:Extracting RAR file"
			if [[ -n "$output_dir" ]]; then
				echo "PROGRESS:50:Decompressing to target directory"
				unrar x -o+ "$archive" "$output_dir" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing RAR extraction"
				break
			else
				echo "PROGRESS:50:Decompressing in current directory"
				unrar x -o+ "$archive" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing RAR extraction"
				break
			fi
			;;
		*.zip)
			echo "PROGRESS:30:Extracting ZIP file"
			if [[ -n "$output_dir" ]]; then
				echo "PROGRESS:50:Decompressing to target directory"
				unzip -o "$archive" -d "$output_dir" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing ZIP extraction"
				break
			else
				echo "PROGRESS:50:Decompressing in current directory"
				unzip -o "$archive" || {
					print_failed "Failed to extract ${C}$archive"
				}
				echo "PROGRESS:90:Finalizing ZIP extraction"
				break
			fi
			;;
		*)
			print_failed "Unsupported archive format: ${C}$archive"
			;;
		esac

		print_warn "Extraction failed, attempt $attempt of $max_retries."
		echo "PROGRESS:$((10 + attempt * 5)):Retrying extraction after failure (Attempt $attempt)"
		sleep 2
		((attempt++))
	done

	if ((attempt > max_retries)); then
		print_failed "Extraction failed after $max_retries attempts: ${C}$archive"
	fi

	echo "PROGRESS:100:Extraction completed: $(basename "$archive")"
	print_success "Extraction completed: ${C}$archive"
}

# find a backup file which end with a number pattern and restore it
function check_and_restore() {
	local target_path="$1"
	local max_retries=3
	local attempt=1

	local dir=$(dirname "$target_path")
	local base_name=$(basename "$target_path")
	local latest_backup=$(find "$dir" -maxdepth 1 -type f -name "$base_name-[0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9].bak" 2>/dev/null | sort | tail -n 1)

	if [[ -z "$latest_backup" ]]; then
		print_failed "No backup file found for ${target_path}."
	fi

	if [[ -e "$target_path" ]]; then
		print_failed "Original file or directory ${target_path} already exists."
	fi

	while ((attempt <= max_retries)); do
		if mv "$latest_backup" "$target_path"; then
			print_success "Restored ${latest_backup} to ${target_path}"
			break
		fi
		((attempt++))
		sleep 1
	done
}

function detact_package_manager() {
	source "/data/data/com.termux/files/usr/bin/termux-setup-package-manager"
	if [[ "$TERMUX_APP_PACKAGE_MANAGER" == "apt" ]]; then
		PACKAGE_MANAGER="apt-get"
	elif [[ "$TERMUX_APP_PACKAGE_MANAGER" == "pacman" ]]; then
		PACKAGE_MANAGER="pacman"
	else
		PACKAGE_MANAGER="pkg"
		print_warn "Using pkg as fallback package manager"
	fi
}

# will check if the package is already installed or not, if it installed then reinstall and print success/failed message
function package_install_and_check {
	log_debug "Starting package installation for: $*"
	packs_list=($@)
	# pacman part
	if [[ "$PACKAGE_MANAGER" == "pacman" ]]; then
		for package_name in "${packs_list[@]}"; do
			if [[ "$package_name" == *"*"* ]]; then
				log_debug "Processing wildcard pattern: $package_name"
				packages=$(pacman -Ssq | grep -E "^${package_name//\*/.*}$")
				log_debug "matched packages: ${C}$packages"
				for package in $packages; do
					retry_count=0
					max_retries=5
					install_success=false
					while [[ "$retry_count" -lt "$max_retries" && "$install_success" == false ]]; do
						retry_count=$((retry_count + 1))
						check_and_delete "$PREFIX/var/lib/pacman/db.lck"
						print_msg "Installing Package : ${C}$package"
						pacman -S --noconfirm "$package"
						if pacman -Qi "$package" >/dev/null 2>&1; then
							print_success "Successfully install package: ${C}$package"
							install_success=true
						else
							print_warn "Failed to install package: ${C}${package}. ${Y}Trying again... ($retry_count)"
						fi
					done
				done
			else
				retry_count=0
				max_retries=5
				install_success=false
				while [[ "$retry_count" -lt "$max_retries" && "$install_success" == false ]]; do
					retry_count=$((retry_count + 1))
					check_and_delete "$PREFIX/var/lib/pacman/db.lck"
					print_msg "Installing Package : ${C}$package_name"
					pacman -S --noconfirm "$package_name"
					if pacman -Qi "$package_name" >/dev/null 2>&1; then
						print_success "Successfully install package: ${C}$package_name"
						install_success=true
					else
						print_warn "Failed to install package: ${C}${package_name}. ${Y}Trying again... ($retry_count)"
					fi
				done
			fi
		done
	else
		#apt part
		for package_name in "${packs_list[@]}"; do
			if [[ "$package_name" == *"*"* ]]; then
				log_debug "Processing wildcard pattern: $package_name"
				packages=$(apt-cache pkgnames | grep -E "^${package_name//\*/.*}$" | sort -u)
				log_debug "matched packages: $packages"
				for package in $packages; do
					retry_count=0
					max_retries=5
					install_success=false
					while [[ "$retry_count" -lt "$max_retries" && "$install_success" == false ]]; do
						retry_count=$((retry_count + 1))
						print_msg "Installing package: ${C}$package"
						apt install "$package" -y
						if dpkg -s "$package" >/dev/null 2>&1; then
							print_success "Successfully install package: ${C}$package"
							install_success=true
						else
							print_warn "Failed to install package: ${C}${package}. ${Y}Trying again... ($retry_count)"
							# Only run recovery commands on failure
							dpkg --configure -a
							apt --fix-broken install -y
							apt install --fix-missing -y
						fi
					done
				done
			else
				retry_count=0
				max_retries=5
				install_success=false
				while [[ "$retry_count" -lt "$max_retries" && "$install_success" == false ]]; do
					retry_count=$((retry_count + 1))
					print_msg "Installing package: ${C}$package_name"
					apt install "$package_name" -y
					if dpkg -s "$package_name" >/dev/null 2>&1; then
						print_success "Successfully install package: ${C}$package_name"
						install_success=true
					else
						print_warn "Failed to install package: ${C}${package_name}. ${Y}Trying again... ($retry_count)"
						# Only run recovery commands on failure
						dpkg --configure -a
						apt --fix-broken install -y
						apt install --fix-missing -y
					fi
				done
			fi
		done
	fi
}

# will check the package is installed or not then remove it
function package_check_and_remove() {
	log_debug "Starting package removal for: $*"
	local packs_list=($@)

	if [[ "$PACKAGE_MANAGER" == "pacman" ]]; then
		for package_name in "${packs_list[@]}"; do
			if [[ "$package_name" == *"*"* ]]; then
				log_debug "Processing wildcard pattern: $package_name"
				local packages=$(pacman -Qsq | grep -E "^${package_name//\*/.*}$")
				if [[ -z "$packages" ]]; then
					print_success "No installed packages found matching: ${C}$package_name"
					continue
				fi
				log_debug "matched packages: $packages"
				for package in $packages; do
					local retry_count=0
					local max_retries=5
					local remove_success=false
					while [[ "$retry_count" -lt "$max_retries" && "$remove_success" == false ]]; do
						retry_count=$((retry_count + 1))
						check_and_delete "$PREFIX/var/lib/pacman/db.lck"
						print_msg "Removing Package : ${C}$package"
						pacman -Rnds --noconfirm "$package"
						if ! pacman -Qi "$package" >/dev/null 2>&1; then
							print_success "Successfully removed package: ${C}$package"
							remove_success=true
						else
							print_warn "Failed to remove package: ${C}${package}. ${Y}Trying again...($retry_count)"
						fi
					done
				done
			else
				if pacman -Qi "$package_name" >/dev/null 2>&1; then
					local retry_count=0
					local max_retries=5
					local remove_success=false
					while [[ "$retry_count" -lt "$max_retries" && "$remove_success" == false ]]; do
						retry_count=$((retry_count + 1))
						check_and_delete "$PREFIX/var/lib/pacman/db.lck"
						print_msg "Removing Package : ${C}$package_name"
						pacman -Rnds --noconfirm "$package_name"
						if ! pacman -Qi "$package_name" >/dev/null 2>&1; then
							print_success "Successfully removed package: ${C}$package_name"
							remove_success=true
						else
							print_warn "Failed to remove package: ${C}${package_name}. ${Y}Trying again... ($retry_count)"
						fi
					done
				else
					print_success "Package ${C}$package_name${G} is not installed.${NC}"
				fi
			fi
		done
	else
		for package_name in "${packs_list[@]}"; do
			if [[ "$package_name" == *"*"* ]]; then
				log_debug "Processing wildcard pattern: $package_name"
				local packages=$(dpkg-query -W -f='${binary:Package}\n' "${package_name}" 2>/dev/null | grep -v ' ')

				if [[ -z "$packages" ]]; then
					print_success "No installed packages found matching: ${C}$package_name"
					continue
				fi

				log_debug "matched packages: $packages"
				for package in $packages; do
					local retry_count=0
					local max_retries=5
					local remove_success=false
					while [[ "$retry_count" -lt "$max_retries" && "$remove_success" == false ]]; do
						retry_count=$((retry_count + 1))
						print_msg "Removing package: ${C}$package"
						dpkg --configure -a >/dev/null
						apt autoremove "$package" -y
						if ! dpkg -s "$package" >/dev/null 2>&1; then
							print_success "Successfully removed package: ${C}$package"
							remove_success=true
						else
							print_warn "Failed to remove package: ${C}${package}. ${Y}Trying again...($retry_count)"
						fi
					done
				done
			else
				if dpkg -s "$package_name" >/dev/null 2>&1; then
					local retry_count=0
					local max_retries=5
					local remove_success=false
					while [[ "$retry_count" -lt "$max_retries" && "$remove_success" == false ]]; do
						retry_count=$((retry_count + 1))
						print_msg "Removing package: ${C}$package_name"
						dpkg --configure -a >/dev/null
						apt autoremove "$package_name" -y
						if ! dpkg -s "$package_name" >/dev/null 2>&1; then
							print_success "Successfully removed package: ${C}$package_name"
							remove_success=true
						else
							print_warn "Failed to remove package: ${C}${package_name}. ${Y}Trying again... ($retry_count)"
						fi
					done
				else
					print_success "Package ${C}$package_name${G} is not installed.${NC}"
				fi
			fi
		done
	fi
}

function get_file_name_number() {
	current_file=$(basename "$0")
	folder_name="${current_file%.sh}"
	theme_number=$(echo "$folder_name" | grep -oE '[1-9][0-9]*')
}

# get the latest version from a github releases
# ex. latest_tag=$(get_latest_release "$repo_owner" "$repo_name")
function get_latest_release() {
	local repo_owner="$1"
	local repo_name="$2"
	curl -s "https://api.github.com/repos/$repo_owner/$repo_name/releases/latest" |
		grep '"tag_name":' |
		sed -E 's/.*"v?([^"]+)".*/\1/'
}

function preprocess_conf() {
	# Preprocess configuration file:
	# 1. Remove lines where keys contain dashes (-).
	# 2. Remove quotes from keys and values.
	echo " Prepering config file..."
	sed -i -E '/^[[:space:]]*[^#=]+-.*=/d; s/^([[:space:]]*[^#=]+)="([^"]*)"/\1=\2/g' "$config_file"
}

function read_conf() {
	if [[ ! -f "$config_file" ]]; then
		print_failed "Configuration file not found: $config_file"
	fi
	source "$config_file"
}

function update_sys() {
	if [[ "$PACKAGE_MANAGER" == "pacman" ]]; then
		pacman -Syu --noconfirm
	else
		apt-get update -y -o Dpkg::Options::="--force-confnew"
		apt-get upgrade -y -o Dpkg::Options::="--force-confnew"
	fi
}

function fix_exec() {
	local file="/data/data/com.termux/files/usr/share/applications/$1"
	sed -i -E "/^Exec=/ {
        /pdrun/ {
            s/\$/ $2/; b
        }
        s|^Exec=([^ ]+)(.*)|Exec=pdrun \1\2 $2|
    }" "$file"
}

function install_appimage() {
	local appimage_file_name="$1"
	local appimage_directory_name="$2"
	distro_run '
check_and_create_directory '/opt/AppImageLauncher/'
check_and_delete '/opt/AppImageLauncher/$appimage_directory_name'
'
	mv -f "$appimage_file_name" "$distro_path/opt/AppImageLauncher/"
	distro_run "
cd /opt/AppImageLauncher
ldconfig
chmod +x '${appimage_file_name}'
APPIMAGE_EXTRACT_AND_RUN=1 ./${appimage_file_name} --appimage-extract
mv -f squashfs-root '$appimage_directory_name'
check_and_delete '${appimage_file_name}'
"
}

function get_latest_version() {
	local package_name
	local latest_version
	package_name=$1
	if [[ "$PACKAGE_MANAGER" == "apt" ]]; then
		latest_version=$(apt-cache policy "$package_name" | grep 'Candidate:' | awk '{print $2}')
	elif [[ "$PACKAGE_MANAGER" == "pacman" ]]; then
		latest_version=$(pacman -Si "$package_name" 2>/dev/null | grep 'Version' | awk '{print $3}')
	fi
	# print version if get
	if [[ -n "$latest_version" ]]; then
		echo "$latest_version"
	fi

}

function create_shell_script() {
	local script_path="$1"
	local shell_setup_content="$2"

	# Create directory if it doesn't exist
	mkdir -p "$(dirname "$script_path")"

	cat <<'EOF' >"$script_path"
#!/bin/bash

termux_desktop_path="/data/data/com.termux/files/usr/etc/termux-desktop"
config_file="$termux_desktop_path/configuration.conf"
log_file="/data/data/com.termux/files/home/termux-desktop.log"

EOF
	typeset -f print_success print_failed check_and_delete check_and_create_directory extract check_and_restore >>"$script_path"
	echo "$shell_setup_content" >>"$script_path"

	# Make script executable
	chmod +x "$script_path"

	# Verify script was created
	if [[ ! -f "$script_path" ]]; then
		print_failed "Failed to create script at $script_path"
	fi
}

function distro_run() {
	local command="$1"
	# Multi-line command - create temporary script
	pd_setup_content="${command}"

	eval "create_shell_script '$distro_path/root/pd_setup.sh' '$pd_setup_content'"
	proot-distro login "$selected_distro" -- /bin/bash /root/pd_setup.sh
}

function pd_package_install_and_check() {
	# Convert arguments to a space-separated string for proper transmission
	local packages_string="$*"

	distro_run "
        # Convert the string back to an array inside the distro
        read -ra packs_list <<< \"$packages_string\"
        total_packages=\${#packs_list[@]}
        current_package=0

        echo \"PROGRESS:0:Starting installation of \$total_packages packages in PRoot distro\"

        # Get distro ID
        if [ -f /etc/os-release ]; then
            . /etc/os-release
        fi

        # Install packages
        for package_name in \"\${packs_list[@]}\"; do
            ((current_package++))
            percent=\$(( (current_package - 1) * 100 / total_packages ))
            echo \"PROGRESS:\$percent:Installing package: \$package_name (\$current_package of \$total_packages)\"

            if [[ \"\$ID\" == \"debian\" ]] || [[ \"\$ID\" == \"ubuntu\" ]]; then
                apt-get update -y > /dev/null
                # Use simpler progress approach
                echo \"PROGRESS:\$(( percent + 25 )):Updating package lists...\"
                apt-get install \"\$package_name\" -y
                echo \"PROGRESS:\$(( percent + 75 )):Installing dependencies...\"
            elif [[ \"\$ID\" == arch* ]]; then
                # Pacman doesn't show progress percentage, so break into steps
                echo \"PROGRESS:\$percent:Syncing repositories for \$package_name\"
                pacman -Sy --noconfirm
                echo \"PROGRESS:\$(( percent + 50 )):Installing \$package_name\"
                pacman -S --noconfirm \"\$package_name\"
            elif [[ \"\$ID\" == \"fedora\" ]]; then
                echo \"PROGRESS:\$percent:Installing \$package_name with dnf\"
                dnf install \"\$package_name\" -y
                echo \"PROGRESS:\$(( percent + 50 )):Finalizing installation...\"
            fi

            # Check if installed
            if command -v \"\$package_name\" >/dev/null 2>&1; then
                final_percent=\$(( (current_package * 100) / total_packages ))
                echo \"PROGRESS:\$final_percent:\$package_name installed successfully\"
                echo \"\$package_name installed successfully\"
            else
                echo \"Error installing \$package_name\"
            fi
        done

        echo \"PROGRESS:100:Package installation in PRoot distro complete\"
    "
}

read_conf
distro_path="/data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs/$selected_distro"
